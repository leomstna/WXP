<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Dream Setup - Versão do Leo (V5)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Menu Lateral */
        #ui-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background-color: #2a2a2a;
            border-right: 2px solid #333;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
            color: white;
            box-shadow: 2px 0 15px rgba(0,0,0,0.5);
        }

        h2 {
            margin-top: 0;
            font-size: 1.2rem;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .btn-movel {
            width: 100%;
            background-color: #444;
            color: white;
            border: none;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 1rem;
            transition: background 0.2s;
            font-weight: bold;
        }

        .btn-movel:hover {
            background-color: #555;
        }

        /* Container do Jogo */
        #game-container {
            flex-grow: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }

        canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>

<div id="ui-panel">
    <h2>Catálogo 2D</h2>
    <button class="btn-movel" onclick="addMovel('mesa')">Mesa de PC</button>
    <button class="btn-movel" onclick="addMovel('cadeira')">Cadeira Gamer</button>
    <button class="btn-movel" onclick="addMovel('cama')">Cama</button>
    <p style="font-size: 0.8rem; color: #888; margin-top: 20px;">
        - Arraste móveis para mover.<br>
        - Arraste o fundo para mover a câmera.<br>
        - Use scroll para zoom.
    </p>
</div>

<div id="game-container">
    <canvas id="gameCanvas" width="1920" height="1080"></canvas>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Configurações do Mundo
    const gridSize = 10;
    const baseTileW = 128;
    const baseTileH = 64; 
    const wallHeight = baseTileH * 4;

    // Variáveis de Câmera
    let camScale = 1.0;
    let camOffsetX = canvas.width / 2;
    let camOffsetY = canvas.height / 2;

    // Estado do Jogo
    let moveis = [];
    let movelArrastado = null;
    let arrastandoCamera = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // --- SISTEMA DE IMAGENS (PRELOAD) ---
    const imagensProntas = {};
    const fontes = {
        'mesa': './assets/mesa.png',
        'cadeira': './assets/cadeira.png',
        'cama': './assets/cama.png'
    };

    for (let tipo in fontes) {
        let img = new Image();
        img.src = fontes[tipo];
        imagensProntas[tipo] = img;
    }
    // ------------------------------------

    function toIso(x, y, z = 0) {
        const tileW = baseTileW * camScale;
        const tileH = baseTileH * camScale;
        const isoX = (x - y) * (tileW / 2);
        const isoY = (x + y) * (tileH / 2) - (z * tileH);
        return { x: isoX + camOffsetX, y: isoY + camOffsetY };
    }

    function toGrid(screenX, screenY) {
        const tileW = baseTileW * camScale;
        const tileH = baseTileH * camScale;
        const adjX = screenX - camOffsetX;
        const adjY = screenY - camOffsetY;
        const gridX = Math.round((adjX / (tileW / 2) + adjY / (tileH / 2)) / 2);
        const gridY = Math.round((adjY / (tileH / 2) - adjX / (tileW / 2)) / 2);
        return { x: gridX, y: gridY };
    }

    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    window.addMovel = function(tipo) {
        moveis.push({
            tipo: tipo,
            mapX: 4,
            mapY: 4,
            isDragging: false,
            dragScreenX: 0,
            dragScreenY: 0,
            offsetX: 0, 
            offsetY: 0  
        });
    }

    function drawPoly(points, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.fill();
    }

    function drawRoom() {
        const p_far = toIso(0, 0);
        const p_right = toIso(gridSize, 0);
        const p_near = toIso(gridSize, gridSize);
        const p_left = toIso(0, gridSize);

        // Chão
        drawPoly([p_far, p_right, p_near, p_left], '#3a3a3a');

        // Parede Esquerda
        const p_far_top = toIso(0, 0, 4);
        const p_left_top = toIso(0, gridSize, 4);
        drawPoly([p_left, p_far, p_far_top, p_left_top], '#555555');

        // Parede Direita
        const p_right_top = toIso(gridSize, 0, 4);
        drawPoly([p_far, p_right, p_right_top, p_far_top], '#4a4a4a');

        // Grade no chão
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1 * camScale;
        for (let x = 0; x <= gridSize; x++) {
            const pStart = toIso(x, 0);
            const pEnd = toIso(x, gridSize);
            ctx.beginPath(); ctx.moveTo(pStart.x, pStart.y); ctx.lineTo(pEnd.x, pEnd.y); ctx.stroke();
        }
        for (let y = 0; y <= gridSize; y++) {
            const pStart = toIso(0, y);
            const pEnd = toIso(gridSize, y);
            ctx.beginPath(); ctx.moveTo(pStart.x, pStart.y); ctx.lineTo(pEnd.x, pEnd.y); ctx.stroke();
        }
    }

    function drawMovel(movel) {
        let base = movel.isDragging 
            ? { x: movel.dragScreenX, y: movel.dragScreenY } 
            : toIso(movel.mapX, movel.mapY);

        let img = imagensProntas[movel.tipo];

        if (img && img.complete && img.naturalWidth !== 0) {
            const drawWidth = img.width * camScale;
            const drawHeight = img.height * camScale;
            const tileH = baseTileH * camScale;

            let drawX = base.x - (drawWidth / 2);
            let drawY = base.y - drawHeight + (tileH / 2);

            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            if (movel.isDragging) {
                ctx.strokeStyle = 'lime';
                ctx.lineWidth = 2;
                ctx.strokeRect(drawX, drawY, drawWidth, drawHeight);
            }
        } else {
            const size = 30 * camScale;
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(base.x - size/2, base.y - size, size, size);
        }
    }

    function render() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawRoom();

        let moveisOrdenados = [...moveis].sort((a, b) => {
            let baseA_Y = a.isDragging ? a.dragScreenY : toIso(a.mapX, a.mapY).y;
            let baseB_Y = b.isDragging ? b.dragScreenY : toIso(b.mapX, b.mapY).y;
            return baseA_Y - baseB_Y;
        });

        for (let movel of moveisOrdenados) {
            drawMovel(movel);
        }

        requestAnimationFrame(render);
    }

    // --- EVENTOS DE MOUSE E CÂMERA ---

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomFactor = 1.1;
        if (e.deltaY < 0) {
            camScale *= zoomFactor;
        } else {
            camScale /= zoomFactor;
        }
        camScale = Math.min(Math.max(0.5, camScale), 3.0);
    });

    canvas.addEventListener('mousedown', (e) => {
        const mouse = getMousePos(e);
        lastMouseX = mouse.x;
        lastMouseY = mouse.y;
        
        let pegouMovel = false;
        
        for (let i = moveis.length - 1; i >= 0; i--) {
            let movel = moveis[i];
            let objBase = toIso(movel.mapX, movel.mapY);
            let img = imagensProntas[movel.tipo];
            
            let acertou = false;

            if (img && img.complete && img.naturalWidth !== 0) {
                const drawWidth = img.width * camScale;
                const drawHeight = img.height * camScale;
                const tileH = baseTileH * camScale;

                let drawX = objBase.x - (drawWidth / 2);
                let drawY = objBase.y - drawHeight + (tileH / 2);

                if (mouse.x >= drawX && mouse.x <= drawX + drawWidth &&
                    mouse.y >= drawY && mouse.y <= drawY + drawHeight) {
                    acertou = true;
                }
            } else {
                const size = 30 * camScale;
                let drawX = objBase.x - size / 2;
                let drawY = objBase.y - size;

                if (mouse.x >= drawX && mouse.x <= drawX + size &&
                    mouse.y >= drawY && mouse.y <= drawY + size) {
                    acertou = true;
                }
            }

            if (acertou) { 
                movel.isDragging = true;
                
                movel.offsetX = objBase.x - mouse.x;
                movel.offsetY = objBase.y - mouse.y;

                movel.dragScreenX = mouse.x + movel.offsetX;
                movel.dragScreenY = mouse.y + movel.offsetY;

                movelArrastado = movel;
                pegouMovel = true;
                
                moveis.push(moveis.splice(i, 1)[0]);
                break; 
            }
        }

        if (!pegouMovel) {
            arrastandoCamera = true;
        }
    });

    window.addEventListener('mousemove', (e) => {
        const mouse = getMousePos(e);

        if (movelArrastado) {
            movelArrastado.dragScreenX = mouse.x + movelArrastado.offsetX;
            movelArrastado.dragScreenY = mouse.y + movelArrastado.offsetY;
        } else if (arrastandoCamera) {
            const dx = mouse.x - lastMouseX;
            const dy = mouse.y - lastMouseY;
            camOffsetX += dx;
            camOffsetY += dy;
            lastMouseX = mouse.x;
            lastMouseY = mouse.y;
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (movelArrastado) {
            const snappedGrid = toGrid(movelArrastado.dragScreenX, movelArrastado.dragScreenY);

            if (snappedGrid.x >= 0 && snappedGrid.x < gridSize && 
                snappedGrid.y >= 0 && snappedGrid.y < gridSize) {
                movelArrastado.mapX = snappedGrid.x;
                movelArrastado.mapY = snappedGrid.y;
            }
            movelArrastado.isDragging = false;
            movelArrastado = null;
        }
        arrastandoCamera = false;
    });

    render();
</script>
</body>
</html>
